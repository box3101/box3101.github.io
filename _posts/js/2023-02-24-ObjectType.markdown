---
layout: post
title: "ObjectType"
date: 2023-02-22 17:53:32 +0900
author: Jeffrey
categories: JavaScript(Es6)
---

# 06-2Object Type2

## **객체 (Object)**

객체는 일종의 배열인데, **인덱스가 Number 타입이 아니라 String타입**이다.

→ String 타입이라 **문자열 형태의 인덱스를 지정**해줘야 한다. (자동으로는 애매하니까 수동으로 지정)

ex. let obj = {"나":"이찬용", "자녀":"이하윤", "배우자":"사모님", "부":"아버지", "모":"어머니", "처부":"장인어른", "처모":"장모님"};

1. **배열**의 인덱스 => Number타입 => **인덱스 (index)**
2. **객체**의 인덱스 => String타입 => **키 (key)**

**JSON방식으로 객체를 만들때에는**, 키가 **변수명명규칙**에 맞는 경우에 한하여, **따옴표를 생략**할 수 있다.

ex. let obj = {나:"이찬용", 자녀:"이하윤", 배우자:"사모님", 부:"아버지", 모:"어머니", 처부:"장인어른", 처모:"장모님"};

**키에 집어넣을 데이터를 변수**에서 가져올 수도 있다.

let name = "이찬용";
le.x et obj = {**나:name,** 자녀:"이하윤", 배우자:"사모님", 부:"아버지", 모:"어머니", 처부:"장인어른", 처모:"장모님"};

키에 집어넣을 데이터를 변수에서 가져오긴 할건데, **키 이름과 변수 이름이 같으면, 축약**할 수 있다.

let **나** = "이찬용";
let obj = {**나**, 자녀:"이하윤", 배우자:"사모님", 부:"아버지", 모:"어머니", 처부:"장인어른", 처모:"장모님"};

## 객체 사용하기

객체는 **일종의 배열이므로 배열을 사용하는 요령과 똑같이 사용**하면 된다.

**키가 변수에 들어있어도 된다.**

let relation = "자녀";
console.log( obj[relation] );

**키가 변수명명규칙에 맞는 경우에 한하여, 다음과 같이 축약하는게 가능하다.**

console.log( obj.자녀 ); // obj["자녀"] // **문자열 따움표 생략 + 꺽세도 생략, 대신 점을 찍어서 나타냄**
ex. **console["log"](https://www.notion.so/06-2Object-Type2-e6c26f6739a142e8a67bd1e781bc71f9); // console.log // console 객체 log 키**

**객체에는 새로운 키를 만드는게 가능하다.**

obj.처남 = "홍길동";
obj["처제"] = "이지은";

**객체에서 키를 제거하는게 가능하다.**

delete obj.처부;
delete obj["처모"];

**주의사항:**
let a = "나";
console.log( obj[a] ); // obj.a 는 불가능! // **변수에 들어있는 키는 축약을 못한다.**

## **객체와 배열의 차이**

배열의 인덱스는 Number타입, 명칭은 인덱스
객체의 인덱스는 String타입, 명칭은 키

```
       0         1         2         3         4         5           6

```

let arr = ["이찬용", "이하윤", "사모님", "아버지", "어머니", "장인어른", "장모님"];

let obj = {"나":"이찬용", "자녀":"이하윤", "배우자":"사모님", "부":"아버지", "모":"어머니", "처부":"장인어른", "처모":"장모님"};

배열에는 **데이터가 들어있는 순서와 방향성이 있다**. => **순차배열** (sequential array)
객체에는 **데이터가 들어있는 순서와 방향성이 없다**. => **연관배열** (associative array)

배열에는 **길이가 있다.** => **길이는 (마지막 인덱스번호 + 1)** 이다.
객체에는 **길이가 없다**. => **마지막 인덱스(키)를 식별할 수 없다**.

arr.push() // 가능. 왜? 오른쪽이 어딘지 아니까.
obj.push() // 불가능. 왜? 오른쪽이 어딘지를 모른다.

arr.length // 가능. 왜? 배열에는 길이가 있으니까.
obj.length // 불가능. 왜? 길이가 없으니까.

## 객체를 순회하기

**배열 순회하기**
for(let i=0; i<arr.length; i+=1) {console.log( arr[i] );} // **인덱스를 가지고 순회**

**객체 순회하기 #1**
for( let k in obj ) {console.log( obj[**k**] );} // **객체의 키들을 하나씩 꺼내옴 , k라는 변수에 키가 하나씩 담김**

**객체 순회하기 #2**
let arr = Object.keys(obj); // **객체를 구성하는 키로 이뤄진 배열이 도출**된다.
for(let i=0; i<arr.length; i+=1) {console.log( obj[arr[i]] );}

## 객체 복사하기

**얕은 복사**
let obj2 = obj; // **바로가기만 복사**

**깊은 복사**
ES6 이전에는, **for-in 구문으로 키를 순회하면서 하나하나 복사**했다.
let obj2 = {};
for( let k in obj ) {obj2[k] = obj[k];}

**깊은 복사**
**스프레드 연산을 이용**해서 **쉽게 복사**한다.
let obj2 = {...obj};
let obj2 = {...obj, "처남":"차은우"}; // **복사를해서 새로운 값 추가 가능**
let obj2 = {...obj, "자녀":"이하윤, 이하준"}; // **키가 중복되면 뒤에꺼가 앞에껄 덮어써서 수정**

## 객체를 사용하는 이유

let 재고 = {"새우깡": 5,"왕뚜껑김치맛": 10,...};

**현실에 존재하는 사물이나 개념을 컴퓨터상에서 표현하는 행위**를 **"추상화(abstraction)**"라고 하는데,
**우리 프로그램에서 다뤄야 할 데이터를 추상화하고 나면 만들어지는 형태가 객체 형태일때 자연스럽고 편리**하다.

{"번호판": "..","차대번호": "..","소유자": {"이름": "..","연락처": "..","주민번호": "..","주소": "..","차종": "..","연식": "..","수리내역": []}

### 1.**메써드 (method),**

객체에 존재하는 여러 키중에, **함수를 담고 있는 키를 "메써드"**라고 부른다. // **호출을 해야함**

### 2.**프로퍼티 (property)**

객체에 존재하는 여러 키중에, **함수가 아닌 것을 담고 있는 키를 "프로퍼티"**라고 부른다.

### 3.this

**메써드 안에서 this 라는 키워드를 사용**할 수 있다.

**this키워드**는 **메써드를 소유**하고 있는 **객체를 지칭**한다.

메써드가 아닌 **그냥 바깥에 나와있는 일반 함수에서 this 키워드는 "전역 컨텍스트 객체 (= Window객체)" 를 지칭**한다.

## **유사배열 (pseudo array)**

외관상 형태는 객체인데, **조건 2가지를 충족해야 한다.**

1. **"length" 프로퍼티가 존재**한다.
2. **키들이 마치 숫자처럼 생겨서 parseInt()가 가능**하다.

**두가지 조건**을 만족하는 객체를 **유사배열**이라고 부른다.

let o = {"0": "이찬용","1": "이하윤",length": 2}; // 1.**키가 숫자처럼 생겨서 paseint가능** , 2.**length라는 프로퍼티 존재**

유사배열은 **실제로는 객체**인데, 프로그래머가 **사용하는 입장에는 그냥 배열이라고 간주해도 무방**하다.

## 객체중에 특수한 형태의 객체

**null** : 변수가 비어있음을 나타낼때 사용하는 객체.

**undefined** => 변수가 비어있어서 데이터타입이 정의되지 않은 상태 => 지금은 변수가 비어있지만 나중에 데이터가 대입된다면 어떤 타입이든 대입 가능
**null** => 변수가 비어있긴 한데 다만 데이터타입은 객체로 정해져 있는 상태 => 지금은 변수가 비어있지만 나중에 데이터가 대입된다면 객체가 대입될 것이다
