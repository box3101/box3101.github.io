---
layout: post
title: "Boolean"
date: 2023-02-22 17:53:32 +0900
author: Jeffrey
categories: JavaScript(Es6)
---

- **진리값 (Boolean)**
  진리값은 참(=true) 또는 거짓(=false) 둘 중 하나의 상태를 나타내는 데이터.
      var a = true;
      var b = false;
- **논리연산: 결과로 진리값이 도출되는 연산**
  5 + 3 = 8
  5 > 3 = true
  <br>   **a) 동등비교연산**: Number, String, Boolean, undefined
      ==              이항연산. 좌항과 우항의 데이터가 같으면 true를 도출하고, 다르면 false를 도출하는 연산.
      묵시적 형 변환이 허용 된다. (느슨한 비교)
      5 == 5 // true
      "이찬용" == "이찬드래곤" // false
      3 == "3" // true

      ===             이항연산. 좌항과 우항의 데이터가 같으면 true를 도출하고, 다르면 false를 도출하는 연산.
      묵시적 형 변환이 허용되지 않는다. (엄격한 비교)
      3 === "3" // false

      !=              이항연산. 좌항과 우항의 데이터가 다르면 true를 도출하고, 같으면 false를 도출하는 연산.
      묵시적 형 변환이 허용 된다. (느슨한 비교)
      3 != 5 // true
      "이찬용" != "이찬용" // false
      3 != "3" // false

      !==             이항연산. 좌항과 우항의 데이터가 다르면 true를 도출하고, 같으면 false를 도출하는 연산.
      묵시적 형 변환이 허용되지 않는다. (엄격한 비교)
      3 !== "3" // true

      NaN 에 대한 동등비교는 불가능하다.
      어떤 연산식의 결과나 변수에 들어있는 데이터가 NaN 인지 확인하려면, isNaN() 기능을 사용해야 한다.

      **b) 대소비교연산: Number**

      > 이항연산. 좌항이 우항보다 크면 true를 도출하고, 작거나 같으면 false를 도출하는 연산.
      >
      >
      > =              이항연산. 좌항이 우항보다 크거나 같으면 true를 도출하고, 작으면 false를 도출하는 연산.
      > <               이항연산. 좌항이 우항보다 작으면 true를 도출하고, 크거나 같으면 false를 도출하는 연산.
      > <=              이항연산. 좌항이 우항보다 작거나 같으면 true를 도출하고, 크면 false를 도출하는 연산.
      >

      c) 논리합성연산: Boolean
      ||              이항연산. 논리 합 연산 (Logical OR). 좌항이나 우항 둘 중 하나라도 true면 전체식이 true가 되는 연산.
      좌항이 true면, 우항은 볼것도 없이 무조건 전체식이 true로 결정되어 버리므로, 그 경우엔 우항은 아예 계산을 안한다.

      &&              이항연산. 논리 곱 연산 (Logical AND). 좌항과 우항 둘 다 true여야 전체식이 true가 되는 연산.
      좌항이 false면, 우항은 볼것도 없이 무조건 전체식이 false로 결정되어 버리므로, 그 경우엔 우항은 아예 계산을 안한다.

      !               단항연산. 논리 부정 연산 (Logical NOT). true가 주어졌으면 false를 도출하고, false가 주어졌으면 true를 도출하는 연산.
- **사용자로부터 진리값을 입력받기**
  var answer = confirm( 사용자에게 보여줄 질문 );
- **Number, String, Boolean 간의 묵시적 형 변환**
  1. **Number타입 데이터를 써야 할 자리에 Boolean타입 데이터를 쓴 경우**
     ex) 1 + true => 2
     진리값 true는 숫자 1 로 취급되고, 진리값 false는 숫자 0 으로 취급된다.
  2. **String타입 데이터를 써야 할 자리에 Boolean타입 데이터를 쓴 경우**
     ex) "이찬용" + false => "이찬용false"
     진리값 true는 문자열 "true" 로 취급되고, 진리값 false는 문자열 "false" 로 취급된다.
  3. **Boolean타입 데이터를 써야 할 자리에 Number타입 데이터를 쓴 경우**
     ex) false || 1 => true
     숫자 0은 false로 취급되고, 0 이 아닌 모든 숫자(음수, 실수 포함)는 true로 취급된다.
  4. **Boolean타입 데이터를 써야 할 자리에 String타입 데이터를 쓴 경우**
     ex) true && "false" => true
     문자열의 길이가 0이면 false로 취급되고, 문자열의 길이가 0이 아니면 true로 취급된다.
  절대로 웹브라우저가 묵시적 형 변환을 하도록 내버려두지 않는다!
- **흐름제어 (flow control)**
  자바스크립트 코드는 위에서 아래방향으로 한줄씩 차례대로 실행되는데, 코드의 실행흐름을 프로그래머가 조작할 수 있는 수단이 흐름제어다.
      **a) 분기 (branch)**
      **a-1) if**
      if( 조건식 ) // 조건식: 진리값 그 자체, 진리값을 도출하는 연산식, 진리값으로 형 변환이 가능한 데이터
      {
      // 조건식이 true인 경우 실행될 문장들;
      } // 블럭 block
      else
      {
      // 조건식이 false인 경우 실행될 문장들;
      }

      ```
          else블럭은 통채로 생략 가능하다.
          블럭 내에서 실행할 문장이 한 문장 뿐이거나 또는 블럭 하나로 취급할 수 있는 경우에는, 중괄호를 생략할 수 있다.

      ```

      **a-2) switch**
      switch( 변수나 데이터 )
      {
      case 데이터1:
      // 주어진 변수나 데이터가 "데이터1"에 대응하는 경우 실행할 문장들;

      ```
          case 데이터2:
                // 주어진 변수나 데이터가 "데이터2"에 대응하는 경우 실행할 문장들;

          case 데이터3:
                // 주어진 변수나 데이터가 "데이터3"에 대응하는 경우 실행할 문장들;

          default:
                // 주어진 변수나 데이터가 어느 case에도 대응하지 않은 경우 실행할 문장들;
          }

          주어진 변수나 데이터에 대응하는 case절을 찾으면 그 자리부터 밑으로 쭉 실행을 이어간다.
          break문을 사용하면 밑으로 쭉 내려가는 실행흐름을 막을 수 있다.
          default절은 생략 가능하다.

      ```

      **b) 반복 (loop)**
      **b-1) while**
      while( 조건식 ) // 조건식: 진리값 그 자체, 진리값을 도출하는 연산식, 진리값으로 형 변환이 가능한 데이터
      {
      // 조건식이 true인 동안 반복해서 실행할 문장들;
      }

      ```
          (조건식 판별 - 블럭내용 실행 -) (조건식 판별 - 블럭내용 실행 -) (조건식 판별 - 블럭내용 실행 -)
          반복횟수를 조절하고 싶으면 루프카운터 변수를 이용해서 조건식이 false가 되는 시점까지 조절 가능.
          블럭 내에서 실행할 문장이 한 문장 뿐이거나 또는 블럭 하나로 취급할 수 있는 경우에는, 중괄호를 생략할 수 있다.
          블럭 내에서 break문을 만나면 블럭의 나머지 내용은 실행하지 않고 조건식을 무시하고 즉시 루프를 탈출한다.
          블럭 내에서 continue문을 만나면 블럭의 나머지 내용은 실행하지 않고 즉시 조건식 판별 순서로 건너뛴다.

      ```

      **b-2) do - while**
      do
      {
      // 조건식이 true인 동안 반복해서 실행할 문장들;
      }
      while( 조건식 ); // 조건식: 진리값 그 자체, 진리값을 도출하는 연산식, 진리값으로 형 변환이 가능한 데이터

      ```
          (블럭내용 실행 - 조건식 판별 -) (블럭내용 실행 - 조건식 판별 -) (블럭내용 실행 - 조건식 판별 -)
          반복횟수를 조절하고 싶으면 루프카운터 변수를 이용해서 조건식이 false가 되는 시점까지 조절 가능.
          블럭 내에서 실행할 문장이 한 문장 뿐이거나 또는 블럭 하나로 취급할 수 있는 경우에는, 중괄호를 생략할 수 있다.
          블럭 내에서 break문을 만나면 블럭의 나머지 내용은 실행하지 않고 조건식을 무시하고 즉시 루프를 탈출한다.
          블럭 내에서 continue문을 만나면 블럭의 나머지 내용은 실행하지 않고 즉시 조건식 판별 순서로 건너뛴다.

      ```

      b-3) for
      for( 초기식 ; 조건식 ; 증감식 ) // 조건식: 진리값 그 자체, 진리값을 도출하는 연산식, 진리값으로 형 변환이 가능한 데이터
      {
      // 조건식이 true인 동안 반복해서 실행할 문장들;
      }

      ```
          (초기식 실행 - 조건식 판별 - 블럭내용 실행 -) (증감식 실행 - 조건식 판별 - 블럭내용 실행 -) (증감식 실행 - 조건식 판별 - 블럭내용 실행 -)
          초기식에서 보통 루프카운터 변수를 만들고 초기화하는 동작을 하는 경우가 많다.
          반복횟수를 조절하고 싶으면 루프카운터 변수를 이용해서 조건식이 false가 되는 시점까지 조절 가능.
          블럭 내에서 실행할 문장이 한 문장 뿐이거나 또는 블럭 하나로 취급할 수 있는 경우에는, 중괄호를 생략할 수 있다.
          블럭 내에서 break문을 만나면 블럭의 나머지 내용은 실행하지 않고 조건식을 무시하고 즉시 루프를 탈출한다.
          블럭 내에서 continue문을 만나면 블럭의 나머지 내용은 실행하지 않고 즉시 증감식 순서로 건너뛴다.
          초기식, 조건식, 증감식은 각각 따로따로 생략이 가능하다. 식이 생략되더라도 각 식을 구분하는 세미콜론은 생략할 수 없다.
          조건식이 없고 블럭 내에서 break를 해주지 않으면 무한루프가 된다.

      ```

      **c) 예외처리 (exception handling)**
      프로그래머가 의도하지 않은 코드의 오작동이나 오류를 "예외(exception)"라고 부른다.
      예외가 발생하면 프로그램의 실행이 멈춰버린다.

      try {
      // 오류가 발생할 가능성이 있는 코드들;
      }
      catch( 변수이름 ) {
      // 오류가 발생한 경우에 실행될 대체 코드들;
      // 변수에는 발생한 오류에 관한 정보가 들어있다;
      }

      catch블럭은 try블럭에서 오류가 발생해야만 실행되는데, 오류 발생여부와 무관하게 프로그래머가 의도적으로 catch블럭을 실행하고 싶을 수도 있다.
      그럴때는 의도적으로 오류를 발생시켜야 하는데,

      throw 뭔가 오류와 관련된 데이터;

      throw문은 반드시 try블럭 안에서 사용해야 하며, 만일 try블럭이 아닌 곳에서 throw문을 사용하면 그냥 오류다.
